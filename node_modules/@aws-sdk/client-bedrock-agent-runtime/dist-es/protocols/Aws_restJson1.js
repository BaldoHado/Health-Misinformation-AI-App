import { awsExpectUnion as __expectUnion, loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody, } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, limitedParseFloat32 as __limitedParseFloat32, map, take, withBaseException, } from "@smithy/smithy-client";
import { BedrockAgentRuntimeServiceException as __BaseException } from "../models/BedrockAgentRuntimeServiceException";
import { AccessDeniedException, BadGatewayException, ConflictException, DependencyFailedException, InternalServerException, ResourceNotFoundException, RetrievalFilter, ServiceQuotaExceededException, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_InvokeAgentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text");
    b.p("agentId", () => input.agentId, "{agentId}", false);
    b.p("agentAliasId", () => input.agentAliasId, "{agentAliasId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        enableTrace: [],
        endSession: [],
        inputText: [],
        sessionState: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RetrieveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/knowledgebases/{knowledgeBaseId}/retrieve");
    b.p("knowledgeBaseId", () => input.knowledgeBaseId, "{knowledgeBaseId}", false);
    let body;
    body = JSON.stringify(take(input, {
        nextToken: [],
        retrievalConfiguration: (_) => se_KnowledgeBaseRetrievalConfiguration(_, context),
        retrievalQuery: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RetrieveAndGenerateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/retrieveAndGenerate");
    let body;
    body = JSON.stringify(take(input, {
        input: (_) => _json(_),
        retrieveAndGenerateConfiguration: (_) => se_RetrieveAndGenerateConfiguration(_, context),
        sessionConfiguration: (_) => _json(_),
        sessionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_InvokeAgentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_cT]: [, output.headers[_xabact]],
        [_sI]: [, output.headers[_xabasi]],
    });
    const data = output.body;
    contents.completion = de_ResponseStream(data, context);
    return contents;
};
export const de_RetrieveCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        retrievalResults: (_) => de_KnowledgeBaseRetrievalResults(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RetrieveAndGenerateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        citations: (_) => de_Citations(_, context),
        output: _json,
        sessionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.bedrockagentruntime#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.bedrockagentruntime#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.bedrockagentruntime#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.bedrockagentruntime#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.bedrockagentruntime#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.bedrockagentruntime#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.bedrockagentruntime#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.bedrockagentruntime#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.bedrockagentruntime#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadGatewayExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceName: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadGatewayException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DependencyFailedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceName: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DependencyFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResponseStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["chunk"] != null) {
            return {
                chunk: await de_PayloadPart_event(event["chunk"], context),
            };
        }
        if (event["trace"] != null) {
            return {
                trace: await de_TracePart_event(event["trace"], context),
            };
        }
        if (event["internalServerException"] != null) {
            return {
                internalServerException: await de_InternalServerException_event(event["internalServerException"], context),
            };
        }
        if (event["validationException"] != null) {
            return {
                validationException: await de_ValidationException_event(event["validationException"], context),
            };
        }
        if (event["resourceNotFoundException"] != null) {
            return {
                resourceNotFoundException: await de_ResourceNotFoundException_event(event["resourceNotFoundException"], context),
            };
        }
        if (event["serviceQuotaExceededException"] != null) {
            return {
                serviceQuotaExceededException: await de_ServiceQuotaExceededException_event(event["serviceQuotaExceededException"], context),
            };
        }
        if (event["throttlingException"] != null) {
            return {
                throttlingException: await de_ThrottlingException_event(event["throttlingException"], context),
            };
        }
        if (event["accessDeniedException"] != null) {
            return {
                accessDeniedException: await de_AccessDeniedException_event(event["accessDeniedException"], context),
            };
        }
        if (event["conflictException"] != null) {
            return {
                conflictException: await de_ConflictException_event(event["conflictException"], context),
            };
        }
        if (event["dependencyFailedException"] != null) {
            return {
                dependencyFailedException: await de_DependencyFailedException_event(event["dependencyFailedException"], context),
            };
        }
        if (event["badGatewayException"] != null) {
            return {
                badGatewayException: await de_BadGatewayException_event(event["badGatewayException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_AccessDeniedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_AccessDeniedExceptionRes(parsedOutput, context);
};
const de_BadGatewayException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_BadGatewayExceptionRes(parsedOutput, context);
};
const de_ConflictException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ConflictExceptionRes(parsedOutput, context);
};
const de_DependencyFailedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_DependencyFailedExceptionRes(parsedOutput, context);
};
const de_InternalServerException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_InternalServerExceptionRes(parsedOutput, context);
};
const de_PayloadPart_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_PayloadPart(data, context));
    return contents;
};
const de_ResourceNotFoundException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ResourceNotFoundExceptionRes(parsedOutput, context);
};
const de_ServiceQuotaExceededException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
};
const de_ThrottlingException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ThrottlingExceptionRes(parsedOutput, context);
};
const de_TracePart_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_TracePart(data, context));
    return contents;
};
const de_ValidationException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ValidationExceptionRes(parsedOutput, context);
};
const se_FilterAttribute = (input, context) => {
    return take(input, {
        key: [],
        value: (_) => se_FilterValue(_, context),
    });
};
const se_FilterValue = (input, context) => {
    return input;
};
const se_KnowledgeBaseRetrievalConfiguration = (input, context) => {
    return take(input, {
        vectorSearchConfiguration: (_) => se_KnowledgeBaseVectorSearchConfiguration(_, context),
    });
};
const se_KnowledgeBaseRetrieveAndGenerateConfiguration = (input, context) => {
    return take(input, {
        generationConfiguration: _json,
        knowledgeBaseId: [],
        modelArn: [],
        retrievalConfiguration: (_) => se_KnowledgeBaseRetrievalConfiguration(_, context),
    });
};
const se_KnowledgeBaseVectorSearchConfiguration = (input, context) => {
    return take(input, {
        filter: (_) => se_RetrievalFilter(_, context),
        numberOfResults: [],
        overrideSearchType: [],
    });
};
const se_RetrievalFilter = (input, context) => {
    return RetrievalFilter.visit(input, {
        andAll: (value) => ({ andAll: se_RetrievalFilterList(value, context) }),
        equals: (value) => ({ equals: se_FilterAttribute(value, context) }),
        greaterThan: (value) => ({ greaterThan: se_FilterAttribute(value, context) }),
        greaterThanOrEquals: (value) => ({ greaterThanOrEquals: se_FilterAttribute(value, context) }),
        in: (value) => ({ in: se_FilterAttribute(value, context) }),
        lessThan: (value) => ({ lessThan: se_FilterAttribute(value, context) }),
        lessThanOrEquals: (value) => ({ lessThanOrEquals: se_FilterAttribute(value, context) }),
        notEquals: (value) => ({ notEquals: se_FilterAttribute(value, context) }),
        notIn: (value) => ({ notIn: se_FilterAttribute(value, context) }),
        orAll: (value) => ({ orAll: se_RetrievalFilterList(value, context) }),
        startsWith: (value) => ({ startsWith: se_FilterAttribute(value, context) }),
        _: (name, value) => ({ name: value }),
    });
};
const se_RetrievalFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RetrievalFilter(entry, context);
    });
};
const se_RetrieveAndGenerateConfiguration = (input, context) => {
    return take(input, {
        knowledgeBaseConfiguration: (_) => se_KnowledgeBaseRetrieveAndGenerateConfiguration(_, context),
        type: [],
    });
};
const de_Attribution = (output, context) => {
    return take(output, {
        citations: (_) => de_Citations(_, context),
    });
};
const de_Citation = (output, context) => {
    return take(output, {
        generatedResponsePart: _json,
        retrievedReferences: (_) => de_RetrievedReferences(_, context),
    });
};
const de_Citations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Citation(entry, context);
    });
    return retVal;
};
const de_InferenceConfiguration = (output, context) => {
    return take(output, {
        maximumLength: __expectInt32,
        stopSequences: _json,
        temperature: __limitedParseFloat32,
        topK: __expectInt32,
        topP: __limitedParseFloat32,
    });
};
const de_KnowledgeBaseLookupOutput = (output, context) => {
    return take(output, {
        retrievedReferences: (_) => de_RetrievedReferences(_, context),
    });
};
const de_KnowledgeBaseRetrievalResult = (output, context) => {
    return take(output, {
        content: _json,
        location: _json,
        metadata: (_) => de_RetrievalResultMetadata(_, context),
        score: __limitedParseDouble,
    });
};
const de_KnowledgeBaseRetrievalResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KnowledgeBaseRetrievalResult(entry, context);
    });
    return retVal;
};
const de_ModelInvocationInput = (output, context) => {
    return take(output, {
        inferenceConfiguration: (_) => de_InferenceConfiguration(_, context),
        overrideLambda: __expectString,
        parserMode: __expectString,
        promptCreationMode: __expectString,
        text: __expectString,
        traceId: __expectString,
        type: __expectString,
    });
};
const de_Observation = (output, context) => {
    return take(output, {
        actionGroupInvocationOutput: _json,
        finalResponse: _json,
        knowledgeBaseLookupOutput: (_) => de_KnowledgeBaseLookupOutput(_, context),
        repromptResponse: _json,
        traceId: __expectString,
        type: __expectString,
    });
};
const de_OrchestrationTrace = (output, context) => {
    if (output.invocationInput != null) {
        return {
            invocationInput: _json(output.invocationInput),
        };
    }
    if (output.modelInvocationInput != null) {
        return {
            modelInvocationInput: de_ModelInvocationInput(output.modelInvocationInput, context),
        };
    }
    if (output.observation != null) {
        return {
            observation: de_Observation(output.observation, context),
        };
    }
    if (output.rationale != null) {
        return {
            rationale: _json(output.rationale),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_PayloadPart = (output, context) => {
    return take(output, {
        attribution: (_) => de_Attribution(_, context),
        bytes: context.base64Decoder,
    });
};
const de_PostProcessingTrace = (output, context) => {
    if (output.modelInvocationInput != null) {
        return {
            modelInvocationInput: de_ModelInvocationInput(output.modelInvocationInput, context),
        };
    }
    if (output.modelInvocationOutput != null) {
        return {
            modelInvocationOutput: _json(output.modelInvocationOutput),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_PreProcessingTrace = (output, context) => {
    if (output.modelInvocationInput != null) {
        return {
            modelInvocationInput: de_ModelInvocationInput(output.modelInvocationInput, context),
        };
    }
    if (output.modelInvocationOutput != null) {
        return {
            modelInvocationOutput: _json(output.modelInvocationOutput),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_RetrievalResultMetadata = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RetrievalResultMetadataValue(value, context);
        return acc;
    }, {});
};
const de_RetrievalResultMetadataValue = (output, context) => {
    return output;
};
const de_RetrievedReference = (output, context) => {
    return take(output, {
        content: _json,
        location: _json,
        metadata: (_) => de_RetrievalResultMetadata(_, context),
    });
};
const de_RetrievedReferences = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RetrievedReference(entry, context);
    });
    return retVal;
};
const de_Trace = (output, context) => {
    if (output.failureTrace != null) {
        return {
            failureTrace: _json(output.failureTrace),
        };
    }
    if (output.orchestrationTrace != null) {
        return {
            orchestrationTrace: de_OrchestrationTrace(__expectUnion(output.orchestrationTrace), context),
        };
    }
    if (output.postProcessingTrace != null) {
        return {
            postProcessingTrace: de_PostProcessingTrace(__expectUnion(output.postProcessingTrace), context),
        };
    }
    if (output.preProcessingTrace != null) {
        return {
            preProcessingTrace: de_PreProcessingTrace(__expectUnion(output.preProcessingTrace), context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_TracePart = (output, context) => {
    return take(output, {
        agentAliasId: __expectString,
        agentId: __expectString,
        sessionId: __expectString,
        trace: (_) => de_Trace(__expectUnion(_), context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _cT = "contentType";
const _sI = "sessionId";
const _xabact = "x-amzn-bedrock-agent-content-type";
const _xabasi = "x-amz-bedrock-agent-session-id";
